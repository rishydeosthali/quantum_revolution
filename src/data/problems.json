{
  "1": {
    "title": "Quantum Superposition with Qiskit",
    "difficulty": "easy",
    "category": "Quantum Fundamentals",
    "acceptance": "87.3%",
    "likes": 142,
    "time": "~15 min",
    "submissions": "12.4K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, build a quantum circuit that puts a single qubit into superposition using a Hadamard gate. Measure the qubit multiple times and analyze the results to confirm that the qubit is equally likely to be found in state |0⟩ or |1⟩. Your goal is to demonstrate and verify the principle of quantum superposition through circuit simulation and measurement statistics.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>create_superposition_circuit():</strong> Create a quantum circuit with a Hadamard gate\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>measure_circuit():</strong> Add measurement to the circuit\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>run_experiment():</strong> Execute the circuit and analyze results\n    </div>\n  </div>\n  <h2>Example Output</h2>\n  <div class=\"code-example\">\n    Circuit measurements should show approximately:<br/>\n    • |0⟩: ~50% of the time<br/>\n    • |1⟩: ~50% of the time\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Use Qiskit QuantumCircuit for circuit creation</li>\n    <li>Apply Hadamard gate for superposition</li>\n    <li>Include proper measurement operations</li>\n    <li>Execute with sufficient shots for statistical analysis</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile, assemble\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\n\ndef create_superposition_circuit():\n    \"\"\"\n    Create a quantum circuit that puts a qubit in superposition.\n    \n    Returns:\n        QuantumCircuit: Circuit with Hadamard gate applied\n    \"\"\"\n    # Create quantum and classical registers\n    qreg = QuantumRegister(1, 'q')\n    creg = ClassicalRegister(1, 'c')\n    circuit = QuantumCircuit(qreg, creg)\n    \n    # Your code here: Apply Hadamard gate\n    \n    return circuit\n\ndef measure_circuit(circuit):\n    \"\"\"\n    Add measurement to the quantum circuit.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n    \n    Returns:\n        QuantumCircuit: Circuit with measurement added\n    \"\"\"\n    # Your code here: Add measurement\n    \n    return circuit\n\ndef run_experiment(circuit, shots=1000):\n    \"\"\"\n    Execute the quantum circuit and return results.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit to execute\n        shots (int): Number of measurement shots\n    \n    Returns:\n        dict: Measurement results\n    \"\"\"\n    # Your code here: Execute circuit using AerSimulator\n    \n    pass\n\n# Test your implementation\ncircuit = create_superposition_circuit()\ncircuit = measure_circuit(circuit)\nresults = run_experiment(circuit)\nprint(\"Measurement results:\", results)"
  },
  "2": {
    "title": "Quantum Entanglement with Bell States",
    "difficulty": "medium",
    "category": "Quantum Entanglement", 
    "acceptance": "73.1%",
    "likes": 89,
    "time": "~25 min",
    "submissions": "8.7K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, construct a quantum circuit that creates a Bell state to demonstrate quantum entanglement between two qubits. Measure both qubits and verify that their outcomes are perfectly correlated, showing that the state cannot be separated into individual qubit states. Your goal is to prove the existence of entanglement through measurement statistics and analysis.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>create_bell_circuit():</strong> Create a 2-qubit circuit with Hadamard + CNOT gates\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>measure_bell_state():</strong> Add measurements to analyze the Bell state\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>analyze_entanglement():</strong> Execute and verify entanglement properties\n    </div>\n  </div>\n  <h2>Expected Results</h2>\n  <div class=\"code-example\">\n    Bell state measurements should show only:<br/>\n    • |00⟩: ~50% probability<br/>\n    • |11⟩: ~50% probability<br/>\n    • |01⟩: ~0% probability<br/>\n    • |10⟩: ~0% probability\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Use 2-qubit QuantumCircuit</li>\n    <li>Apply Hadamard gate to first qubit</li>\n    <li>Apply CNOT gate between qubits</li>\n    <li>Verify perfect correlation in measurements</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile, assemble\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\nimport matplotlib.pyplot as plt\n\ndef create_bell_circuit():\n    \"\"\"\n    Create a quantum circuit that generates a Bell state |Φ⁺⟩.\n    \n    Returns:\n        QuantumCircuit: Circuit that creates Bell state\n    \"\"\"\n    # Create 2-qubit circuit\n    qreg = QuantumRegister(2, 'q')\n    creg = ClassicalRegister(2, 'c') \n    circuit = QuantumCircuit(qreg, creg)\n    \n    # Your code here:\n    # 1. Apply Hadamard gate to first qubit\n    # 2. Apply CNOT gate with first qubit as control, second as target\n    \n    return circuit\n\ndef measure_bell_state(circuit):\n    \"\"\"\n    Add measurements to the Bell state circuit.\n    \n    Args:\n        circuit (QuantumCircuit): The Bell state circuit\n    \n    Returns:\n        QuantumCircuit: Circuit with measurements added\n    \"\"\"\n    # Your code here: Add measurements for both qubits\n    \n    return circuit\n\ndef analyze_entanglement(circuit, shots=1000):\n    \"\"\"\n    Execute the Bell state circuit and analyze results.\n    \n    Args:\n        circuit (QuantumCircuit): The complete Bell circuit\n        shots (int): Number of measurement shots\n    \n    Returns:\n        dict: Measurement results showing entanglement\n    \"\"\"\n    # Your code here: Execute circuit and return results\n    \n    pass\n\n# Test your implementation\nbell_circuit = create_bell_circuit()\nbell_circuit = measure_bell_state(bell_circuit)\nresults = analyze_entanglement(bell_circuit)\nprint(\"Bell state results:\", results)"
  },
  "3": {
    "title": "Quantum Circuit Simulator",
    "difficulty": "medium",
    "category": "Quantum Circuits",
    "acceptance": "64.2%",
    "likes": 156,
    "time": "~45 min",
    "submissions": "9.3K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, build a basic quantum circuit simulator that allows users to construct, visualize, and execute quantum circuits with single-qubit and multi-qubit gates. Your goal is to provide functions for circuit creation, gate application, and simulation, enabling users to experiment with different gate sequences and observe the resulting measurement statistics.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>create_circuit():</strong> Initialize a quantum circuit with specified qubits\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>apply_gates():</strong> Apply a sequence of gates to the circuit\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>simulate_circuit():</strong> Execute and measure the final state\n    </div>\n  </div>\n  <h2>Example Usage</h2>\n  <div class=\"code-example\">\n    circuit = create_circuit(2)<br/>\n    apply_gates(circuit, [('H', 0), ('X', 1), ('CX', 0, 1)])<br/>\n    results = simulate_circuit(circuit)\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Support X, Y, Z, H gates</li>\n    <li>Handle multi-qubit circuits</li>\n    <li>Include CNOT gate functionality</li>\n    <li>Return measurement statistics</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.visualization import plot_histogram\n\ndef create_circuit(num_qubits):\n    \"\"\"\n    Create a quantum circuit with specified number of qubits.\n    \n    Args:\n        num_qubits (int): Number of qubits in the circuit\n    \n    Returns:\n        QuantumCircuit: Initialized quantum circuit\n    \"\"\"\n    # Your code here\n    pass\n\ndef apply_gates(circuit, gate_sequence):\n    \"\"\"\n    Apply a sequence of gates to the circuit.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        gate_sequence (list): List of tuples (gate_name, qubit_index(es))\n    \n    Returns:\n        QuantumCircuit: Circuit with gates applied\n    \"\"\"\n    # Your code here\n    # Handle gates: 'X', 'Y', 'Z', 'H', 'CX'\n    pass\n\ndef simulate_circuit(circuit, shots=1000):\n    \"\"\"\n    Execute the quantum circuit and return measurement results.\n    \n    Args:\n        circuit (QuantumCircuit): The complete circuit\n        shots (int): Number of measurement shots\n    \n    Returns:\n        dict: Measurement results\n    \"\"\"\n    # Your code here: Add measurements and execute\n    pass\n\n# Test your implementation\ncircuit = create_circuit(2)\napply_gates(circuit, [('H', 0), ('CX', 0, 1)])\nresults = simulate_circuit(circuit)\nprint(\"Circuit results:\", results)"
  },
"4": {
    "title": "Grover's Search Algorithm",
    "difficulty": "medium",
    "category": "Quantum Algorithms",
    "acceptance": "52.8%",
    "likes": 203,
    "time": "~60 min",
    "submissions": "7.1K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, implement Grover's quantum search algorithm to find a marked item in an unsorted database. Build the oracle and diffusion operator, and run the algorithm for the optimal number of iterations to maximize the probability of finding the target item. Your goal is to demonstrate quadratic speedup over classical search and verify the success probability through simulation.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>create_oracle():</strong> Build oracle that marks the target state\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>diffusion_operator():</strong> Implement amplitude amplification\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>grovers_algorithm():</strong> Complete algorithm with optimal iterations\n    </div>\n  </div>\n  <h2>Expected Behavior</h2>\n  <div class=\"code-example\">\n    For 4-item search (2 qubits):<br/>\n    • Target item probability: ~100%<br/>\n    • Other items probability: ~0%<br/>\n    • Optimal iterations: 1\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Implement oracle for any target state</li>\n    <li>Calculate optimal iteration count</li>\n    <li>Use controlled-Z gates for marking</li>\n    <li>Achieve >90% success probability</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nimport numpy as np\n\ndef create_oracle(num_qubits, target_state):\n    \"\"\"\n    Create oracle that marks the target state.\n    \n    Args:\n        num_qubits (int): Number of qubits\n        target_state (str): Binary string of target (e.g., '10')\n    \n    Returns:\n        QuantumCircuit: Oracle circuit\n    \"\"\"\n    # Your code here\n    pass\n\ndef diffusion_operator(num_qubits):\n    \"\"\"\n    Create the diffusion operator for amplitude amplification.\n    \n    Args:\n        num_qubits (int): Number of qubits\n    \n    Returns:\n        QuantumCircuit: Diffusion operator circuit\n    \"\"\"\n    # Your code here\n    pass\n\ndef grovers_algorithm(num_qubits, target_state, shots=1000):\n    \"\"\"\n    Implement complete Grover's algorithm.\n    \n    Args:\n        num_qubits (int): Number of qubits\n        target_state (str): Target state to find\n        shots (int): Number of measurement shots\n    \n    Returns:\n        dict: Measurement results\n    \"\"\"\n    # Your code here:\n    # 1. Initialize superposition\n    # 2. Apply optimal number of Grover iterations\n    # 3. Measure and return results\n    pass\n\n# Test your implementation\nresults = grovers_algorithm(2, '10')\nprint(\"Grover results:\", results)\nprint(f\"Target state probability: {results.get('10', 0)}\")"
  },
  "5": {
    "title": "Quantum Fourier Transform",
    "difficulty": "hard",
    "category": "Quantum Algorithms",
    "acceptance": "38.5%",
    "likes": 178,
    "time": "~90 min",
    "submissions": "5.2K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, construct the Quantum Fourier Transform (QFT) circuit for an arbitrary number of qubits. Apply the QFT to a given input state and verify its correctness by applying the inverse QFT and checking if the original state is recovered. Your goal is to understand and implement the core building block for many quantum algorithms and confirm its functionality through simulation.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>qft_rotations():</strong> Apply controlled rotation gates\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>swap_registers():</strong> Reverse qubit order\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>quantum_fourier_transform():</strong> Complete QFT circuit\n    </div>\n  </div>\n  <h2>Verification Method</h2>\n  <div class=\"code-example\">\n    Apply QFT to |001⟩ state:<br/>\n    • Should produce equal superposition with phases<br/>\n    • Verify with inverse QFT returning |001⟩\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Use controlled phase rotation gates</li>\n    <li>Implement for arbitrary number of qubits</li>\n    <li>Include swap operations for bit reversal</li>\n    <li>Verify with QFT†QFT = I</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nimport numpy as np\nfrom qiskit.extensions import UnitaryGate\n\ndef qft_rotations(circuit, n):\n    \"\"\"\n    Apply the rotational gates for QFT.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        n (int): Number of qubits\n    \"\"\"\n    # Your code here:\n    # Apply H gate and controlled rotations\n    pass\n\ndef swap_registers(circuit, n):\n    \"\"\"\n    Swap the qubit registers to reverse the order.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        n (int): Number of qubits\n    \"\"\"\n    # Your code here\n    pass\n\ndef quantum_fourier_transform(n):\n    \"\"\"\n    Create a QFT circuit for n qubits.\n    \n    Args:\n        n (int): Number of qubits\n    \n    Returns:\n        QuantumCircuit: Complete QFT circuit\n    \"\"\"\n    circuit = QuantumCircuit(n)\n    \n    # Your code here:\n    # 1. Apply QFT rotations\n    # 2. Swap registers\n    \n    return circuit\n\ndef test_qft(n, input_state):\n    \"\"\"\n    Test QFT implementation.\n    \n    Args:\n        n (int): Number of qubits\n        input_state (str): Binary input state\n    \n    Returns:\n        dict: Test results\n    \"\"\"\n    # Your code here: Test QFT with input state\n    pass\n\n# Test your implementation\nqft_circuit = quantum_fourier_transform(3)\nresults = test_qft(3, '001')\nprint(\"QFT test results:\", results)"
  },
  "6": {
    "title": "Variational Quantum Eigensolver",
    "difficulty": "hard",
    "category": "Quantum Chemistry",
    "acceptance": "31.2%",
    "likes": 134,
    "time": "~120 min",
    "submissions": "4.1K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, implement a Variational Quantum Eigensolver (VQE) that finds the ground state energy of a molecular Hamiltonian. Build a parameterized ansatz circuit, measure the expectation value of the Hamiltonian, and optimize the parameters using a classical optimizer. Your goal is to achieve chemical accuracy for the ground state energy of the H₂ molecule and demonstrate the hybrid quantum-classical workflow.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>create_ansatz():</strong> Build parameterized quantum circuit\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>measure_hamiltonian():</strong> Calculate expectation value ⟨H⟩\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>optimize_vqe():</strong> Classical optimization loop\n    </div>\n  </div>\n  <h2>Test Case</h2>\n  <div class=\"code-example\">\n    H₂ molecule Hamiltonian:<br/>\n    • Expected ground state energy: ~-1.137<br/>\n    • Use RY rotations and CNOT gates<br/>\n    • Optimize with COBYLA or SPSA\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Implement hardware-efficient ansatz</li>\n    <li>Handle Pauli string Hamiltonians</li>\n    <li>Use classical optimizer (scipy)</li>\n    <li>Achieve chemical accuracy (1 kcal/mol)</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nfrom qiskit.opflow import Z, I, X, Y\nfrom scipy.optimize import minimize\nimport numpy as np\n\ndef create_ansatz(num_qubits, depth=1):\n    \"\"\"\n    Create a hardware-efficient ansatz circuit.\n    \n    Args:\n        num_qubits (int): Number of qubits\n        depth (int): Circuit depth (layers)\n    \n    Returns:\n        QuantumCircuit: Parameterized ansatz circuit\n    \"\"\"\n    # Your code here:\n    # Use RY rotations and CNOT entangling gates\n    pass\n\ndef measure_hamiltonian(circuit, hamiltonian, parameters):\n    \"\"\"\n    Measure expectation value of Hamiltonian.\n    \n    Args:\n        circuit (QuantumCircuit): Ansatz circuit\n        hamiltonian: Pauli string Hamiltonian\n        parameters (list): Circuit parameters\n    \n    Returns:\n        float: Expectation value ⟨ψ(θ)|H|ψ(θ)⟩\n    \"\"\"\n    # Your code here\n    pass\n\ndef optimize_vqe(hamiltonian, num_qubits, max_iter=100):\n    \"\"\"\n    Run VQE optimization to find ground state.\n    \n    Args:\n        hamiltonian: Target Hamiltonian\n        num_qubits (int): Number of qubits\n        max_iter (int): Maximum optimization iterations\n    \n    Returns:\n        dict: Optimization results\n    \"\"\"\n    # Your code here:\n    # 1. Initialize parameters\n    # 2. Define cost function\n    # 3. Run classical optimization\n    pass\n\n# H2 molecule Hamiltonian (simplified)\nH2_hamiltonian = -1.0523732 * (I ^ I) + 0.39793742 * (I ^ Z) - 0.39793742 * (Z ^ I) - 0.01128010 * (Z ^ Z) + 0.18093120 * (X ^ X)\n\n# Test your implementation\nresults = optimize_vqe(H2_hamiltonian, 2)\nprint(\"VQE results:\", results)\nprint(f\"Ground state energy: {results.get('energy', 'N/A')}\")"
  },
  "7": {
    "title": "Quantum Error Correction",
    "difficulty": "hard",
    "category": "Error Correction",
    "acceptance": "29.6%",
    "likes": 95,
    "time": "~105 min",
    "submissions": "3.8K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, implement quantum error correction codes by building the 3-qubit bit flip code and the 9-qubit Shor code. Encode a logical qubit, introduce a single bit flip error, detect the error using syndrome measurements, and apply corrections. Your goal is to demonstrate that quantum information can be protected and recovered with high fidelity through error correction protocols.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>encode_qubit():</strong> Encode logical qubit into code space\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>syndrome_measurement():</strong> Detect error syndromes\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>error_correction():</strong> Apply corrections based on syndrome\n    </div>\n  </div>\n  <h2>Error Model</h2>\n  <div class=\"code-example\">\n    Test with single bit flip errors:<br/>\n    • Apply X gate to random qubit<br/>\n    • Measure syndrome: 01, 10, or 11<br/>\n    • Correct and verify fidelity >99%\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Implement 3-qubit repetition code</li>\n    <li>Use ancilla qubits for syndrome measurement</li>\n    <li>Handle single bit flip errors</li>\n    <li>Demonstrate error correction fidelity</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nimport numpy as np\nimport random\n\ndef encode_qubit(circuit, data_qubit, code_qubits):\n    \"\"\"\n    Encode a logical qubit using 3-qubit repetition code.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        data_qubit (int): Index of data qubit to encode\n        code_qubits (list): Indices of 3 code qubits\n    \"\"\"\n    # Your code here:\n    # Use CNOT gates to create |000⟩ or |111⟩\n    pass\n\ndef syndrome_measurement(circuit, code_qubits, ancilla_qubits):\n    \"\"\"\n    Measure error syndrome without disturbing the code space.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        code_qubits (list): Indices of code qubits\n        ancilla_qubits (list): Indices of ancilla qubits\n    \"\"\"\n    # Your code here:\n    # Use CNOT gates to measure parity\n    pass\n\ndef apply_error_correction(circuit, syndrome, code_qubits):\n    \"\"\"\n    Apply error correction based on syndrome measurement.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        syndrome (str): Syndrome measurement result\n        code_qubits (list): Indices of code qubits\n    \"\"\"\n    # Your code here:\n    # Apply X gates based on syndrome\n    pass\n\ndef test_error_correction(initial_state, error_qubit=None):\n    \"\"\"\n    Test the complete error correction protocol.\n    \n    Args:\n        initial_state (str): '0' or '1'\n        error_qubit (int): Qubit to apply error (None for random)\n    \n    Returns:\n        dict: Test results including fidelity\n    \"\"\"\n    # Your code here:\n    # 1. Prepare initial state\n    # 2. Encode with 3-qubit code\n    # 3. Apply error\n    # 4. Measure syndrome and correct\n    # 5. Decode and measure fidelity\n    pass\n\n# Test your implementation\nresults = test_error_correction('1', error_qubit=1)\nprint(\"Error correction results:\", results)\nprint(f\"Correction fidelity: {results.get('fidelity', 'N/A')}\")"
  },
  "8": {
    "title": "Quantum Teleportation Protocol",
    "difficulty": "medium",
    "category": "Quantum Communication",
    "acceptance": "56.7%",
    "likes": 167,
    "time": "~50 min",
    "submissions": "6.4K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, implement the quantum teleportation protocol to transfer an unknown quantum state from one qubit to another using entanglement and classical communication. Prepare an arbitrary input state, create a Bell pair, perform Alice's measurement, and apply Bob's correction. Your goal is to verify that the final state matches the original with high fidelity and demonstrate the principles of quantum communication.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>create_bell_pair():</strong> Generate entangled pair for Alice & Bob\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>alice_measurement():</strong> Bell state measurement + classical bits\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>bob_correction():</strong> Apply corrections based on classical data\n    </div>\n  </div>\n  <h2>Test Protocol</h2>\n  <div class=\"code-example\">\n    Teleport arbitrary state α|0⟩ + β|1⟩:<br/>\n    • Alice measures her qubits<br/>\n    • Sends 2 classical bits to Bob<br/>\n    • Bob applies corrections and recovers |ψ⟩\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Prepare arbitrary input states</li>\n    <li>Create maximally entangled pairs</li>\n    <li>Implement Bell state measurement</li>\n    <li>Verify teleportation fidelity >99%</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nimport numpy as np\nfrom qiskit.quantum_info import Statevector\n\ndef create_bell_pair(circuit, qubit1, qubit2):\n    \"\"\"\n    Create a Bell pair between two qubits.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        qubit1 (int): First qubit index\n        qubit2 (int): Second qubit index\n    \"\"\"\n    # Your code here:\n    # Create |Φ⁺⟩ = (|00⟩ + |11⟩)/√2\n    pass\n\ndef alice_measurement(circuit, psi_qubit, alice_qubit, cbits):\n    \"\"\"\n    Alice performs Bell state measurement.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        psi_qubit (int): Qubit with unknown state |ψ⟩\n        alice_qubit (int): Alice's entangled qubit\n        cbits (list): Classical bit indices for measurement\n    \"\"\"\n    # Your code here:\n    # 1. CNOT and Hadamard operations\n    # 2. Measure both qubits\n    pass\n\ndef bob_correction(circuit, bob_qubit, classical_bits):\n    \"\"\"\n    Bob applies corrections based on Alice's measurement.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        bob_qubit (int): Bob's qubit index\n        classical_bits (list): Alice's measurement results\n    \"\"\"\n    # Your code here:\n    # Apply X and/or Z gates based on classical bits\n    pass\n\ndef quantum_teleportation(input_state_params, shots=1000):\n    \"\"\"\n    Execute complete quantum teleportation protocol.\n    \n    Args:\n        input_state_params (tuple): (theta, phi) for |ψ⟩ = cos(θ/2)|0⟩ + e^(iφ)sin(θ/2)|1⟩\n        shots (int): Number of measurement shots\n    \n    Returns:\n        dict: Teleportation results and fidelity\n    \"\"\"\n    # Your code here:\n    # 1. Prepare input state |ψ⟩\n    # 2. Create Bell pair\n    # 3. Alice measures\n    # 4. Bob corrects\n    # 5. Verify teleportation\n    pass\n\n# Test your implementation\ntheta, phi = np.pi/3, np.pi/4  # Example state parameters\nresults = quantum_teleportation((theta, phi))\nprint(\"Teleportation results:\", results)\nprint(f\"Teleportation fidelity: {results.get('fidelity', 'N/A')}\")"
  },
  "9": {
    "title": "Shor's Factoring Algorithm",
    "difficulty": "hard",
    "category": "Quantum Algorithms",
    "acceptance": "22.4%",
    "likes": 245,
    "time": "~150 min",
    "submissions": "2.9K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, implement Shor's algorithm for factoring integers. Build the modular exponentiation and period finding circuits, apply the quantum Fourier transform, and use classical post-processing to extract the period and factors. Your goal is to demonstrate quantum speedup in integer factorization and verify the correctness of the factors found through simulation and analysis.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>modular_exponentiation():</strong> Implement controlled modular exponentiation\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>period_finding():</strong> Use QFT to find period\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>shors_algorithm():</strong> Complete factoring algorithm\n    </div>\n  </div>\n  <h2>Test Case</h2>\n  <div class=\"code-example\">\n    Factor N = 15 with a = 7:<br/>\n    • Period r = 4 (since 7⁴ ≡ 1 mod 15)<br/>\n    • Factors: gcd(7²±1, 15) = {3, 5}<br/>\n    • Verify: 3 × 5 = 15\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Implement controlled modular exponentiation</li>\n    <li>Use quantum Fourier transform</li>\n    <li>Handle continued fractions for period extraction</li>\n    <li>Verify factorization results</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nimport numpy as np\nfrom math import gcd\nfrom fractions import Fraction\n\ndef modular_exponentiation(circuit, control_qubits, target_qubits, a, N):\n    \"\"\"\n    Implement controlled modular exponentiation: |x⟩|y⟩ → |x⟩|y⋅a^x mod N⟩\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        control_qubits (list): Control qubit indices\n        target_qubits (list): Target qubit indices\n        a (int): Base for exponentiation\n        N (int): Modulus\n    \"\"\"\n    # Your code here:\n    # Implement controlled multiplication gates\n    pass\n\ndef period_finding_circuit(a, N, n_count_qubits):\n    \"\"\"\n    Create quantum circuit for period finding.\n    \n    Args:\n        a (int): Base for modular exponentiation\n        N (int): Number to factor\n        n_count_qubits (int): Number of counting qubits\n    \n    Returns:\n        QuantumCircuit: Period finding circuit\n    \"\"\"\n    # Your code here:\n    # 1. Initialize superposition in counting register\n    # 2. Apply controlled modular exponentiation\n    # 3. Apply inverse QFT\n    pass\n\ndef classical_post_processing(measurement_results, N):\n    \"\"\"\n    Extract period from measurement results using continued fractions.\n    \n    Args:\n        measurement_results (dict): QFT measurement results\n        N (int): Number being factored\n    \n    Returns:\n        int: Extracted period\n    \"\"\"\n    # Your code here:\n    # Use continued fractions to find period\n    pass\n\ndef shors_algorithm(N, max_attempts=10):\n    \"\"\"\n    Complete Shor's factoring algorithm.\n    \n    Args:\n        N (int): Number to factor\n        max_attempts (int): Maximum attempts\n    \n    Returns:\n        dict: Factorization results\n    \"\"\"\n    # Your code here:\n    # 1. Choose random a < N\n    # 2. Check if gcd(a, N) > 1\n    # 3. Find period using quantum circuit\n    # 4. Extract factors from period\n    pass\n\n# Test your implementation\nN = 15  # Example: factor 15\nresults = shors_algorithm(N)\nprint(\"Shor's algorithm results:\", results)\nif 'factors' in results:\n    factors = results['factors']\n    print(f\"Factors of {N}: {factors[0]} × {factors[1]} = {factors[0] * factors[1]}\")"
  },
  "10": {
    "title": "Quantum Walk Implementation",
    "difficulty": "medium",
    "category": "Quantum Algorithms",
    "acceptance": "47.3%",
    "likes": 112,
    "time": "~70 min",
    "submissions": "5.7K",
    "description": "<div class=\"problem-content\">\n  <h2>Problem Statement</h2>\n  <p>Using Qiskit, simulate discrete-time quantum walks by implementing coin and shift operators. Initialize the walker, perform multiple steps, and measure the final position distribution. Your goal is to compare the spreading behavior of quantum walks with classical random walks and visualize the probability distributions to highlight quantum speedup and interference effects.</p>\n  <h2>Tasks</h2>\n  <div class=\"task-list\">\n    <div class=\"task-item\">\n      <span class=\"task-number\">1</span>\n      <strong>coin_operator():</strong> Apply quantum coin flip\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">2</span>\n      <strong>shift_operator():</strong> Conditional position shift\n    </div>\n    <div class=\"task-item\">\n      <span class=\"task-number\">3</span>\n      <strong>quantum_walk():</strong> Complete walk simulation\n    </div>\n  </div>\n  <h2>Walk Analysis</h2>\n  <div class=\"code-example\">\n    After T steps on infinite line:<br/>\n    • Classical: position ~ O(√T)<br/>\n    • Quantum: position ~ O(T)<br/>\n    • Observe interference effects\n  </div>\n  <h2>Requirements</h2>\n  <ul class=\"requirements-list\">\n    <li>Implement coin and shift operators</li>\n    <li>Handle periodic boundary conditions</li>\n    <li>Visualize probability distributions</li>\n    <li>Compare with classical random walk</li>\n  </ul>\n</div>",
    "starterCode": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef coin_operator(circuit, coin_qubit, coin_angle=np.pi/2):\n    \"\"\"\n    Apply quantum coin operator.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        coin_qubit (int): Coin qubit index\n        coin_angle (float): Rotation angle for coin\n    \"\"\"\n    # Your code here:\n    # Apply rotation (Hadamard or RY gate)\n    pass\n\ndef shift_operator(circuit, coin_qubit, position_qubits):\n    \"\"\"\n    Apply conditional shift based on coin state.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        coin_qubit (int): Coin qubit index\n        position_qubits (list): Position qubit indices\n    \"\"\"\n    # Your code here:\n    # Increment/decrement position based on coin\n    pass\n\ndef increment_gate(circuit, qubits):\n    \"\"\"\n    Implement quantum increment gate for position register.\n    \n    Args:\n        circuit (QuantumCircuit): The quantum circuit\n        qubits (list): Qubit indices for position register\n    \"\"\"\n    # Your code here:\n    # Implement ripple-carry adder\n    pass\n\ndef quantum_walk(num_steps, num_position_qubits, coin_angle=np.pi/2):\n    \"\"\"\n    Simulate discrete-time quantum walk.\n    \n    Args:\n        num_steps (int): Number of walk steps\n        num_position_qubits (int): Number of position qubits\n        coin_angle (float): Coin rotation angle\n    \n    Returns:\n        dict: Position probability distribution\n    \"\"\"\n    # Your code here:\n    # 1. Initialize walker at center position\n    # 2. Apply coin and shift operators for each step\n    # 3. Measure final position distribution\n    pass\n\ndef compare_walks(num_steps, trials=1000):\n    \"\"\"\n    Compare quantum vs classical random walk.\n    \n    Args:\n        num_steps (int): Number of steps\n        trials (int): Number of trials for classical walk\n    \n    Returns:\n        dict: Comparison results\n    \"\"\"\n    # Your code here:\n    # Compare spreading of quantum vs classical walks\n    pass\n\n# Test your implementation\nqwalk_results = quantum_walk(10, 4)\nprint(\"Quantum walk results:\", qwalk_results)\n\ncomparison = compare_walks(10)\nprint(\"Walk comparison:\", comparison)"
  }
}